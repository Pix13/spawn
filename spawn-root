#!/bin/sh

program_name="spawn-root"

S=$(printf '\t')

container_name=
container_user="dev"
container_home="/home/$container_user"
container_command=

xauth_file="/tmp/xauth"
x11_unix_dir="/tmp/.X11-unix"
pulseaudio_dir="/run/pulse"

show_help() {
    cat <<EOF
Usage: $program_name [OPTIONS...] [--] [COMMAND [ARGS...]]

  Spawns new container or chroot and configures shared environment.

OPTIONS:

  -h|--help             Print this help message
  -d|--directory <dir>  A directory to use as a root filesystem
  -n|--name <name>      A name of the container to run
  -r|--as-root          Use superuser inside the spawned root
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as user home directory
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $x11_unix_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --umount              Just unmount directories for the specified root name
  --using-nspawn        Use systemd-nspawn instead of chroot call
  --using-docker        Use Docker to run the named container

SYNOPSIS:

  To run custom command inside the chroot pass it after --.

EOF
}

parse_command_line() {
    local parsing_command=

    while [ $# -gt 0 ]; do
        if [ "$parsing_command" ]; then
            container_command="${container_command}${S}$1"
        else
            case $1 in
                --)
                    parsing_command=1 ;;
                -h|--help) show_help; exit ;;
                -d|--directory)
                    root_dir="$2"; shift ;;
                -n|--name)
                    container_name="$2"; shift ;;
                -r|--as-root)
                    container_user='root' ;;
                --arch)
                    root_arch="$2"; shift ;;
                --bind-home)
                    bind_home="$2"; shift ;;
                --with-ssh-agent)
                    with_ssh_agent=1 ;;
                --with-x11)
                    with_x11=1 ;;
                --with-system-bus)
                    with_system_bus=1 ;;
                --with-pulseaudio)
                    with_pulseaudio=1 ;;
                --umount)
                    umount_only=1 ;;
                --share-system)
                    share_system=1 ;;
                --using-nspawn)
                    using_nspawn=1 ;;
                --using-docker)
                    using_docker=1 ;;
                -*)
                    die "unknown argument: $1" ;;
                *)
                    container_command="$1"
                    parsing_command=1
                    ;;
            esac
        fi
        shift
    done
}

check_arguments() {
    if [ "$using_docker" ]; then
        [ "$container_name" ] ||
            die "container name was not specified"
    else
        [ "$root_dir" ] ||
            die "root directory was not specified"
        [ -d "$root_dir" ] ||
            die "root directory '$root_dir' is not exists"

        if [ -z "$using_nspawn" ]; then
            [ "$(command -v dirname)" ] ||
                die "dirname command was not found"
            [ "$(command -v realpath)" ] ||
                die "realpath command was not found"
            [ "$(command -v awk)" ] ||
                die "awk command was not found"
            [ "$(command -v tac)" ] ||
                die "tac command was not found"
        fi
    fi

    if [ "$bind_home" ]; then
        [ -d "$bind_home" ] ||
            die "The directory '$bind_home' is not exists"
    fi

    if [ "$with_ssh_agent" ]; then
        [ "$SSH_AUTH_SOCK" ] ||
            die "SSH_AUTH_SOCK is not set"
        [ -e "$SSH_AUTH_SOCK" ] ||
            die "$SSH_AUTH_SOCK is not exists"
    fi
}

die() {
    local status=$?
    [ $status = 0 ] && status=2
    [ $# = 0 ] || echo Error: $*
    exit $status
}

su_run() {
    if [ "$UID" = "0" ]; then
        "$@"
    else
        sudo "$@"
    fi
}

try_source() { [ -f "$1" ] && . "$1" || :; }

load_config() {
    if [ "$XDG_CONFIG_HOME" ]; then
        try_source "$XDG_CONFIG_HOME/$program_name/env"
    else
        try_source "$HOME/.config/$program_name/env"
    fi
}

set_container_home() {
    if [ "$container_user" = 'root' ]; then
        container_home="/root"
    else
        container_home="/home/$container_user"
    fi
}

extract_xauth() {
    [ "$DISPLAY" ] ||
        die "DISPLAY is not set"

    xauth extract "$root_dir/$xauth_file" "$DISPLAY" ||
        die "failed to extract X authorization entries"
}

copy_pulseaudio_cookie() {
    : ${root_dir:?}
    : ${container_home:?}

    [ -d "/run/user/$UID/pulse" ] ||
        die "Pulseaudio runtime directory is not exists"

    mkdir -p "$root_dir/$container_home/.config/pulse"
    cp -f "$HOME/.config/pulse/cookie" \
        "$root_dir/$container_home/.config/pulse/cookie"
}

copy_resolv_conf() {
    : ${root_dir:?}

    su_run cp -L /etc/resolv.conf "$root_dir/etc/resolv.conf" ||
        die "failed to copy resolv.conf"
}

fix_mtab() {
    : ${root_dir:?}

    if [ ! -h "$root_dir/etc/mtab" ]; then
        su_run ln -sf /proc/self/mounts "$root_dir/etc/mtab" ||
            die "failed to link mtab"
    fi
}

mount_filesystems() {
    local ssh_sock_dir

    : ${root_dir:?}

    su_run mkdir -p "$root_dir/proc"           || die
    su_run mount -t proc proc "$root_dir/proc" || die

    if [ "$share_system" ]; then
        su_run mkdir -p "$root_dir/sys"            || die
        su_run mount --rbind /sys "$root_dir/sys"  || die
        su_run mount --make-rslave "$root_dir/sys" || die

        su_run mkdir -p "$root_dir/dev"            || die
        su_run mount --rbind /dev "$root_dir/dev"  || die
        su_run mount --make-rslave "$root_dir/dev" || die
    fi

    if [ "$bind_home" ]; then
        su_run mount --bind "$bind_home" "$root_dir/$container_home"
    fi

    if [ "$with_ssh_agent" ]; then
        ssh_sock_dir=$(dirname "$SSH_AUTH_SOCK")
        su_run mkdir -p "$root_dir/$ssh_sock_dir" || die
        su_run mount --bind "$ssh_sock_dir" "$root_dir/$ssh_sock_dir" || die
    fi

    if [ "$with_x11" ]; then
        su_run mkdir -p "$root_dir/$x11_unix_dir" || die
        su_run mount --bind "$x11_unix_dir" "$root_dir/$x11_unix_dir" || die
    fi

    if [ "$with_pulseaudio" ]; then
        su_run mkdir -p "$root_dir/$pulseaudio_dir" || die
        su_run mount --bind /run/user/$UID/pulse "$root_dir/$pulseaudio_dir" || die
    fi
}

unmount_filesystems() {
    : ${root_dir:?}

    local root=$(realpath "$root_dir")

    for mp in $(awk -v i="$root" '$2~i {print $2}' /proc/mounts | tac)
    do
        su_run umount "$mp" || true
    done
}

spawn_root_chroot() {
    local userspec= path= setarch=

    : ${root_dir:?}
    : ${container_user:?}
    : ${container_home:?}

    if [ "$container_user" = 'root' ]; then
        userspec="0:0"
        path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    else
        userspec="$USER:users"
        path="/usr/local/bin:/usr/bin:/bin"
    fi

    case $root_arch in
        x86|i?86)
            setarch="linux32" ;;
        x86-64|x86_64|amd64)
            setarch="linux64" ;;
    esac

    su_run $setarch env - \
        HOME="$container_home" \
        USER="$container_user" \
        LOGNAME="$container_user" \
        PATH="$path" \
        TERM="$TERM" \
        ${with_ssh_agent:+SSH_AUTH_SOCK="$SSH_AUTH_SOCK"} \
        chroot --userspec="$userspec" \
            "$root_dir" \
            ${container_command:-/bin/bash --login}
}

spawn_root_docker() {
    local IFS=$(printf '\n\t')
    local args=

    : ${container_name:?}
    : ${container_user:?}

    args="--user=$container_user"

    if [ "$bind_home" ]; then
        args="${args}${S}--volume=$bind_home:$container_home"
    fi

    if [ "$with_ssh_agent" ]; then
        args="${args}${S}--env=SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
        args="${args}${S}--volume=$SSH_AUTH_SOCK:$SSH_AUTH_SOCK"
    fi

    docker run --rm -it \
        ${share_system:+--privileged} \
        $args $container_name \
        $container_command
}

spawn_root_systemd() {
    local IFS=$(printf '\n\t')
    local personality=
    local args=

    : ${root_dir:?}
    : ${container_user:?}

    if [ "$bind_home" ]; then
        args="${args}${S}--bind=${bind_home}:${container_home}"
    fi

    if [ "$with_ssh_agent" ]; then
        args="${args}${S}--setenv=SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
        args="${args}${S}--bind=$SSH_AUTH_SOCK"
    fi

    if [ "$with_x11" ]; then
        args="${args}${S}--setenv=DISPLAY=$DISPLAY"
        args="${args}${S}--setenv=XAUTHORITY=$xauth_file"
        args="${args}${S}--setenv=QT_X11_NO_MITSHM=1"
        args="${args}${S}--bind=$x11_unix_dir"
    fi

    if [ "$with_system_bus" ]; then
        args="${args}${S}--bind=/run/dbus"
    fi

    if [ "$with_pulseaudio" ]; then
        args="${args}${S}--setenv=PULSE_SERVER=$pulseaudio_dir/native"
        args="${args}${S}--bind=/run/user/$UID/pulse:$pulseaudio_dir"
    fi

    case $root_arch in
        x86|i?86)
            personality="x86" ;;
        x86-64|x86_64|amd64)
            personality="x86-64" ;;
    esac

    su_run systemd-nspawn \
        --directory="$root_dir" \
        --user="$container_user" \
        ${share_system:+--share-system} \
        ${personality:+--personality="$personality"} \
        $args $container_command
}

if [ $# = 0 ]; then
    show_help
    exit
fi

load_config

parse_command_line "$@"

check_arguments

if [ "$umount_only" ]; then
    unmount_filesystems
    exit
fi

set_container_home

if [ "$using_docker" ]; then
    spawn_root_docker
elif [ "$using_nspawn" ]; then
    spawn_root_systemd
else
    trap unmount_filesystems EXIT
    mount_filesystems
    spawn_root_chroot
fi
