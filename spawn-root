#!/bin/sh

set -e

program_name="spawn-root"
base_dir="/usr/local/root"

root_user="user"

xauth_file="/tmp/xauth"
x11_unix_dir="/tmp/.X11-unix"

try_source() { [ -f "$1" ] && . "$1" || :; }

die() {
    local status=$?
    [ $status = 0 ] && status=2
    [ $# = 0 ] || echo Error: $*
    exit $status
}

if [ "$XDG_CONFIG_HOME" ]; then
    try_source "$XDG_CONFIG_HOME/$program_name/env"
else
    try_source "$HOME/.config/$program_name/env"
fi

root_command=''

while [ $# -gt 0 ]; do
    if [ "$arg_flag" ]; then
        root_command="$root_command$1 "
    else
        case $1 in
            --)
                arg_flag=1 ;;
            --nspawn)
                nspawn=1 ;;
            -n|--name)
                root_name="$2"; shift ;;
            -r|--as-root)
                root_user='root' ;;
            --bind-home)
                bind_home=1 ;;
            --with-ssh-agent)
                with_ssh_agent=1 ;;
            --with-x11)
                with_x11=1 ;;
            --with-system-bus)
                with_system_bus=1 ;;
            --with-pulseaudio)
                with_pulseaudio=1 ;;
            --desktop)
                use_desktop=1 ;;
            --umount)
                umount_only=1 ;;
            *)
                die "unknown argument: $1" ;;
        esac
    fi
    shift
done

show_help() {
    cat <<EOF
Usage: spawn-root -n <name> [OPTIONS] -- [COMMAND]

  Spawns new container or chroot and configures shared environment.

OPTIONS:

  -n		Name of root inside '$base_dir'
  -c		Use chroot.
  -r		Use superuser account inside the container.
  --umount	Unmount previously mounted filesystems.
  --bind-host	Bind mount host filesystem.
  --bind-root	Bind mount sibling roots.

EOF
}

su_run() {
    if [ "$UID" -eq 0 ]; then
        "$@"
    else
        sudo "$@"
    fi
}

if [ -z "$root_name" ]; then
    die "no root name specified"
fi

root_dir="$base_dir/$root_name"

if [ ! -d "$root_dir" ]; then
    die "root directory '$root_dir' is not exists"
fi

if [ -z "$nspawn" -a -z "$(command -v realpath)" ]; then
    die "realpath command was not found in PATH, can not continue"
fi

if [ "$root_user" = 'root' ]; then
    root_home="/root"
else
    root_home="/home/$root_user"
fi

if [ "$umount_only" ]; then
    unmount_filesystems
    exit
fi

if [ "$with_ssh_agent" ]; then
    [ "$SSH_AUTH_SOCK" ] ||
        die "SSH_AUTH_SOCK is not set"
    [ -e "$SSH_AUTH_SOCK" ] ||
        die "$SSH_AUTH_SOCK is not exists"
fi

if [ "$with_x11" ]; then
    [ "$DISPLAY" ] ||
        die "DISPLAY is not set"

    xauth extract "$root_dir/$xauth_file" "$DISPLAY" ||
        die "failed to extract X authorization entries"
fi

if [ "$with_pulseaudio" ]; then
    [ -d "/run/user/$UID/pulse" ] ||
        die "Pulseaudio runtime directory is not exists"

    mkdir -p "$root_dir/$root_home/.config/pulse"
    cp -f "$HOME/.config/pulse/cookie" \
        "$root_dir/$root_home/.config/pulse/cookie"
fi

if [ ! -h "$root_dir/etc/mtab" ]; then
    su_run ln -sf /proc/self/mounts "$root_dir/etc/mtab" ||
        die "failed to link mtab"
fi

su_run cp -L /etc/resolv.conf "$root_dir/etc/resolv.conf" ||
    die "failed to copy resolv.conf"

mount_filesystems() {
    : ${root_dir:?}

    su_run mkdir -p "$root_dir/proc"
    su_run mount -t proc proc "$root_dir/proc"

    su_run mkdir -p "$root_dir/sys"
    su_run mount --rbind /sys "$root_dir/sys"
    su_run mount --make-rslave "$root_dir/sys"

    su_run mkdir -p "$root_dir/dev"
    su_run mount --rbind /dev "$root_dir/dev"
    su_run mount --make-rslave "$root_dir/dev"

    if [ "$bind_home" ]; then
        su_run mount --bind "$HOME" "$root_dir/$root_home"
    else
        if [ "$with_x11" ]; then
            su_run mkdir -p "$root_dir/tmp/.X11-unix"
            su_run mount --bind /tmp/.X11-unix "$root_dir/tmp/.X11-unix"
        fi

        if [ "$with_pulseaudio" ]; then
            su_run mkdir -p "$root_dir/run/pulse"
            su_run mount --bind /run/user/$UID/pulse "$root_dir/run/pulse"
        fi
    fi
}

unmount_filesystems() {
    : ${root_dir:?}

    local root=$(realpath "$root_dir")

    for mp in $(awk -v i="$root" '$2~i {print $2}' /proc/mounts | tac)
    do
        su_run umount "$mp" || true
    done
}

spawn_root_chroot() {
    : ${root_dir:?}
    : ${root_user:?}
    : ${root_home:?}

    if [ "$root_user" = 'root' ]; then
        _userspec="0:0"
    else
        _userspec="$USER:users"
    fi

    su_run linux32 env - HOME="$root_home" TERM="$TERM" \
        chroot --userspec="$_userspec" "$root_dir" \
        ${root_command:-/bin/bash --login}
}

spawn_root_systemd() {
    : ${root_dir:?}
    : ${root_user:?}

    local nspawn='su_run systemd-nspawn --personality=x86'

    if [ "$with_ssh_agent" ]; then
        local ssh_agent_arg="--setenv=SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
            --bind=$SSH_AUTH_SOCK"
    fi

    if [ "$with_x11" ]; then
        local x11_arg="--setenv=DISPLAY=$DISPLAY \
            --setenv=XAUTHORITY=$xauth_file \
            --bind=$x11_unix_dir"
    fi

    if [ "$with_system_bus" ]; then
        local system_bus_arg="--bind=/run/dbus"
    fi

    if [ "$with_pulseaudio" ]; then
        local pulseaudio_arg="--setenv=PULSE_SERVER=/run/pulse/native \
            --bind=/run/user/$UID/pulse:/run/pulse"
    fi

    local qt_arg="--setenv=QT_X11_NO_MITSHM=1"

    $nspawn --directory="$root_dir" \
        --user=$root_user \
        $ssh_agent_arg \
        $x11_arg ${x11_arg:+$qt_arg} \
        $system_bus_arg \
        $pulseaudio_arg \
        $root_command
}

if [ "$nspawn" ]; then
    spawn_root_systemd
else
    trap unmount_filesystems EXIT
    mount_filesystems
    spawn_root_chroot
fi
