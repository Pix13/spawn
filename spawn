#!/bin/sh

set -u

program_name="spawn"

S=$(printf '\t')

root_dir=
container_type=
container_name=
container_user="dev"
container_group="users"
container_home=
container_command=
passthrough_args=

root_arch=
with_ssh_agent=
with_pulseaudio=
with_x11=
cleanup_only=
share_system=
bind_home=
chroot=

xauth_file=
xsock_dir='/tmp/.X11-unix'

show_usage() {
    cat <<EOF
Usage: $program_name [OPTIONS...] <name|directory> [--] [COMMAND [ARGS...]]

  Spawns new container or chroot and configures shared environment.

OPTIONS:

  -h|--help             Print this help message
  -r|--as-root          Use superuser inside the spawned root
  --user <name>         Assume <name> user inside the container
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as user home directory
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $xsock_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --cleanup             Execute cleanup procedures only
  --share-system        Share dev and sys with the host
  --using-docker        Run command in a new Docker container
  --using-chroot        Change the root directory using chroot

SYNOPSIS:

  Unknown options before <name|directory> are passed to the selected launcher
  as arguments (docker run, chroot, etc.). Everything else after
  <name|directory> and optional '--' are considered the command to be invoked
  inside the spawned container or chroot.

  Options starting with '--using' are mutually exclusive -- only the last one
  will have an effect. If none was given and the first non option argument
  specifies an existing directory then chroot will be assumed, otherwise the
  name will be passed to 'docker run'.

EOF
}

parse_command_line() {
    local parsing_command= eoa=

    while [ $# -gt 0 ]; do
        if [ "$parsing_command" ]; then
            container_command="${container_command}${S}${1}"
        else
            case $1 in
                --)
                    parsing_command=1 ;;
                -h|--help) show_usage; exit ;;
                -r|--as-root)
                    container_user='root' ;;
                -u|--user)
                    container_user="$2"; shift ;;
                --arch)
                    root_arch="$2"; shift ;;
                --bind-home)
                    bind_home="$2"; shift ;;
                --with-ssh-agent)
                    with_ssh_agent=1 ;;
                --with-x11)
                    with_x11=1 ;;
                --with-pulseaudio)
                    with_pulseaudio=1 ;;
                --cleanup)
                    cleanup_only=1 ;;
                --share-system)
                    share_system=1 ;;
                --using-docker)
                    container_type='docker' ;;
                --using-nspawn)
                    container_type='nspawn' ;;
                --using-chroot)
                    container_type='chroot' ;;
                -*)
                    passthrough_args="${passthrough_args}${S}$1" ;;
                *)
                    if [ -d "$1" ]; then
                        container_type="${container_type:-chroot}"
                        root_dir="$1"
                    else
                        container_type="${container_type:-docker}"
                        container_name="$1"
                    fi
                    parsing_command=1
                    # allow optional '--' after the first non-option argument
                    [ "${2-}" = '--' ] && shift
                    ;;
            esac
        fi
        shift
    done
}

validate_environment() {
    if [ -z "$container_type" ]; then
        die "unable to determine container type from the arguments, probably \
no name or directory was given or the specified directory does not exist"
    fi

    case $container_type in
        chroot|nspawn)
            [ "$root_dir" ] ||
                die "root directory is not specified"
            [ -d "$root_dir" ] ||
                die "root directory '$root_dir' is not exists"
            [ -f "$root_dir/etc/passwd" ] ||
                die "/etc/passwd is not exists in '$root_dir'"
            user_exists "$container_user" ||
                die "the specified user '$container_user' is not found in '$root_dir'"
            ;;
        docker)
            [ "$container_name" ] ||
                die "container name is not specified"
    esac

    case $container_type in
        nspawn)
            [ "$(command -v systemd-nspawn)" ] ||
                die "systemd-nspawn command was not found"
            ;;
        chroot)
            [ "$(command -v dirname)" ] ||
                die "dirname command was not found"
            [ "$(command -v realpath)" ] ||
                die "realpath command was not found"
            [ "$(command -v awk)" ] ||
                die "awk command was not found"
            [ "$(command -v tac)" ] ||
                die "tac command was not found"
            [ "$(command -v unshare)" ] ||
                die "unshare command was not found"

            chroot=$(command -v chroot)
            if [ -z "$chroot" ]; then
                chroot="/usr/sbin/chroot"
            fi
            if ! [ -x "$chroot" ]; then
                die "chroot command was not found"
            fi

            ;;
    esac
}

die() {
    local status=$?
    [ $status = 0 ] && status=2
    [ $# = 0 ] || echo Error: $*
    exit $status
}

su_run() {
    if [ "${UID-}" = "0" ]; then
        "$@"
    else
        sudo "$@"
    fi
}

escape_quote() {
    local arg= result=
    for arg in "$@"; do
        arg=$(printf "%s" "$arg" | sed "s/'/'\\\''/g")
        result="$result${S}'$arg'"
    done
    echo "$result"
}

print_args() {
    printf "%d: " $#
    printf "<%s> " "$@"
    printf "\n"
}

user_exists() {
    grep -q "^$1:" "$root_dir/etc/passwd"
}

find_user_info() {
    local field="$1"
    if [ "$root_dir" ]; then
        [ -f "$root_dir/etc/passwd" ] || return
        while IFS=: read -r user pass uid gid gecos home shell; do
            if [ "$user" = "$container_user" ]; then
                eval "echo \$$field"
                break
            fi
        done < "$root_dir/etc/passwd"
    else
        case $container_user in
            root)
                case $field in
                     user) echo root ;;
                      uid) echo 0 ;;
                      gid) echo 0 ;;
                     home) echo /root ;;
                    shell) echo /bin/bash ;;
                esac ;;
            *)
                case $field in
                     user) echo $container_user ;;
                      uid) echo 1000 ;;
                      gid) echo 100  ;;
                     home) echo /home/$container_user ;;
                    shell) echo /bin/bash ;;
                esac ;;
        esac
    fi
}

get_config_dir() {
    local home_dir="$(find_user_info home)"
    local config_dir="$home_dir/.config"

    echo "$config_dir${1:+/$1}"
}

get_runtime_dir() {
    local uid="$(find_user_info uid)"
    local runtime_dir="/run/user/${uid:?}"

    echo "$runtime_dir${1:+/$1}"
}

get_pa_socket() {
    if [ "$(command -v pactl)" ]; then
        pactl info 2>/dev/null | \
            awk '/Server String: / { print $3 }' | \
            sed 's/^unix://'
    fi
}

get_command() {
    case $container_type in
        chroot)
            if [ "$container_command" ]; then
                echo "$(escape_quote $container_command)"
            else
                echo "/bin/sh${S}-c${S}'cd && exec /bin/bash -l'"
            fi ;;
        nspawn)
            if [ "$container_command" ]; then
                echo "$container_command"
            else
                echo "/bin/sh${S}-c${S}cd && exec /bin/bash -l"
            fi ;;
        docker)
            if [ "$container_command" ]; then
                echo "$container_command"
            fi ;;
    esac
}

in_mkdir() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o $uid -g $gid -d "$1" || die
}

in_touch() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o "$uid" -g "$gid" -d "$(dirname "$1")" || die
    su_run touch "$1" || die
    su_run chown "$uid:$gid" "$1" || die
}

in_mount() {
    su_run mount "$@" || die
}

add_user_arg() {
    local _A=

    if [ "$container_type" = "chroot" ]; then
        _A="--userspec=$container_user:users"
    else
        _A="--user=$container_user"
    fi

    eval "${1}=\"\$${1}$S$_A\""
}

add_privileged_arg() {
    local _A=

    [ "${share_system-}" ] || return 0

    case $container_type in
        nspawn)
            _A="--share-system" ;;
        docker)
            _A="--privileged" ;;
    esac

    eval "${1}=\"\$${1}$S$_A\""
}

make_setarch() {
    case $root_arch in
        x86|i?86)
            echo "linux32" ;;
        x86-64|x86_64|amd64)
            echo "linux64" ;;
    esac
}

make_env_arg() {
    local value="$1"
    case $container_type in
        chroot) echo "$value" ;;
        nspawn) echo "--setenv=$value" ;;
        docker) echo "--env=$value" ;;
    esac
}

make_bind_arg() {
    local value="$1"
    case $container_type in
        nspawn) echo "--bind=$value" ;;
        docker) echo "--volume=$value" ;;
    esac
}

setup_ssh_env() {
    local SSH_A=

    [ "${with_ssh_agent-}" ] || return 0

    [ "$SSH_AUTH_SOCK" ] ||
        die "SSH_AUTH_SOCK is not set"
    [ -S "$SSH_AUTH_SOCK" ] ||
        die "$SSH_AUTH_SOCK socket is not exists"

    SSH_A="$SSH_A$S$(make_env_arg "SSH_AUTH_SOCK=$SSH_AUTH_SOCK")"

    if [ "$root_dir" ]; then
        in_touch "$root_dir/$SSH_AUTH_SOCK"
    fi

    if [ "$container_type" = "chroot" ]; then
        in_mount --bind "$SSH_AUTH_SOCK" "$root_dir/$SSH_AUTH_SOCK"
    else
        SSH_A="$SSH_A$S$(make_bind_arg "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK")"
    fi

    eval "${1}=\"\$${1}$S$SSH_A\""
}

setup_x11_env() {
    local X11_A=

    [ "${with_x11-}" ] || return 0

    [ "$DISPLAY" ] ||
        die "passing of X11 environment is enabled but DISPLAY is not set"
    [ -d "$xsock_dir" ] ||
        die "X11 socket directory '$xsock_dir' is not exists"

    X11_A="$X11_A$S$(make_env_arg "DISPLAY=$DISPLAY")"
    X11_A="$X11_A$S$(make_env_arg "XAUTHORITY=$xauth_file")"

    # disable Qt's usage of shared memory which we do not expose
    X11_A="$X11_A$S$(make_env_arg QT_X11_NO_MITSHM=1)"

    if [ "$root_dir" ]; then
        in_touch "$root_dir/$xauth_file"
        in_mkdir "$root_dir/$xsock_dir"
    fi

    if [ "$container_type" = "chroot" ]; then
        in_mount --bind "$xauth_file" "$root_dir/$xauth_file"
        in_mount --bind "$xsock_dir" "$root_dir/$xsock_dir"
    else
        X11_A="$X11_A$S$(make_bind_arg "$xauth_file:$xauth_file")"
        X11_A="$X11_A$S$(make_bind_arg "$xsock_dir:$xsock_dir")"
    fi

    eval "${1}=\"\$${1}$S$X11_A\""
}

setup_pa_env() {
    local PA_A=
    local pa_sock= in_pa_sock=
    local cookie_file= in_cookie_file=

    [ "${with_pulseaudio-}" ] || return 0

    pa_sock=$(get_pa_socket)
    in_pa_sock="$(get_runtime_dir pulse)/native"

    [ -S "$pa_sock" ] || die "PulseAudio socket '$pa_sock' does not exist"

    cookie_file="$HOME/.config/pulse/cookie"
    in_cookie_file="$(get_config_dir pulse)/cookie"

    PA_A="$PA_A$S$(make_env_arg "PULSE_SERVER=$in_pa_sock")"

    if [ "$root_dir" ]; then
        in_touch "$root_dir/$in_pa_sock"
        in_touch "$root_dir/$in_cookie_file"
    fi

    if [ "$container_type" = "chroot" ]; then
        in_mount --bind "$pa_sock" "$root_dir/$in_pa_sock"
        in_mount --bind "$cookie_file" "$root_dir/$in_cookie_file"
    else
        PA_A="$PA_A$S$(make_bind_arg "$pa_sock:$in_pa_sock")"
        PA_A="$PA_A$S$(make_bind_arg "$cookie_file:$in_cookie_file")"
    fi

    chmod 666 "$cookie_file" || die

    eval "${1}=\"\$${1}$S$PA_A\""
}

setup_home_env() {
    local HOME_A=

    [ "$bind_home" ] || return 0

    [ -d "$bind_home" ] ||
        die "The directory '$bind_home' is not exists"

    if [ "$root_dir" ]; then
        in_mkdir "$root_dir/$container_home"
    fi

    if [ "$container_type" = "chroot" ]; then
        in_mount --bind "$bind_home" "$root_dir/$container_home"
    else
        HOME_A="$HOME_A$S$(make_bind_arg "$bind_home:$container_home")"
    fi

    eval "${1}=\"\$${1}$S$HOME_A\""
}

setup_env() {
    setup_ssh_env  "$1"
    setup_x11_env  "$1"
    setup_pa_env   "$1"
    setup_home_env "$1"
}

extract_xauth() {
    xauth_file=$(mktemp)
    # Use wildcard authentication family because hostname of container can
    # differ from the host and default Xauthority files are hostname specific.
    # See http://stackoverflow.com/a/25280523 for details.
    xauth nlist "$DISPLAY" | sed 's/^..../ffff/' | xauth -f "$xauth_file" nmerge -
}

copy_resolv_conf() {
    su_run cp -L /etc/resolv.conf "$root_dir/etc/resolv.conf" ||
        die "failed to copy resolv.conf"
}

fix_mtab() {
    if [ ! -h "$root_dir/etc/mtab" ]; then
        su_run ln -sf /proc/self/mounts "$root_dir/etc/mtab" ||
            die "failed to link mtab"
    fi
}

cleanup() {
    local root=

    if [ "$container_type" = 'chroot' ]; then
        root="$(realpath "$root_dir")"
        for mp in $(awk -v i="$root" '$2~i {print $2}' /proc/mounts | tac)
        do
            su_run umount "$mp" || true
        done
    fi
}

spawn_root_chroot() {
    local IFS="$S"
    local env= local cmd= mount_cmd= chroot_cmd=

    mount_cmd="mount -t proc proc \"$root_dir/proc\" &&"

    if [ "$share_system" ]; then
        su_run mkdir -p "$root_dir/sys"            || die
        su_run mount --rbind /sys "$root_dir/sys"  || die
        su_run mount --make-rslave "$root_dir/sys" || die
        su_run mkdir -p "$root_dir/dev"            || die
        su_run mount --rbind /dev "$root_dir/dev"  || die
        su_run mount --make-rslave "$root_dir/dev" || die
    else
        if [ -h "$root_dir/dev/shm" ]; then
            su_run rm "$root_dir/dev/shm"
        fi
        su_run mkdir -p "$root_dir/dev/shm" "$root_dir/dev/pts"

        mount_cmd="$mount_cmd $(cat <<EOF
mount -t tmpfs -o nosuid,nodev,noexec shm "$root_dir/dev/shm" && \
mount -t devpts -o nosuid,noexec,gid=5,mode=620 devpts "$root_dir/dev/pts" &&
EOF
)"
    fi

    env="${env}${S}TERM=$TERM"
    env="${env}${S}HOME=$container_home"
    env="${env}${S}USER=$container_user"
    env="${env}${S}LOGNAME=$container_user"
    if [ "$container_user" = "root" ]; then
        env="${env}${S}PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    else
        env="${env}${S}PATH=/usr/local/bin:/usr/bin:/bin"
    fi

    setup_env env

    chroot_cmd="$chroot"
    add_user_arg chroot_cmd
    chroot_cmd="$chroot_cmd \"$root_dir\""

    mount_cmd="$mount_cmd $chroot_cmd $(get_command)"

    su_run $(make_setarch) env - $env unshare -m /bin/sh -c "$mount_cmd"
}

spawn_root_nspawn() {
    local IFS="$S" A=

    # systemd-nspawn runs 'getent passwd <user>' inside the container to get
    # passwd entry for the user or fails with "Failed to resolve user <user>"
    add_user_arg A
    add_privileged_arg A
    setup_env A

    su_run systemd-nspawn $A $passthrough_args -D "$root_dir" -- \
        $(get_command)
}

spawn_root_docker() {
    local IFS="$S" A=

    add_user_arg A
    add_privileged_arg A
    setup_env A

    docker run --rm -it $A $passthrough_args $container_name \
        $(get_command)
}

if [ $# = 0 ]; then
    show_usage
    exit
fi

parse_command_line "$@"
validate_environment

if [ "$cleanup_only" ]; then
    cleanup
    exit
fi

trap cleanup EXIT

container_home=$(find_user_info home)
[ "$container_home" ] ||
    die "failed to find user's home directory"

# ensure these directories exist and owned by user
if [ "$root_dir" ]; then
    in_mkdir "$root_dir/$(get_runtime_dir)"
    in_mkdir "$root_dir/$(get_config_dir)"
fi

if [ "$with_x11" ]; then
    extract_xauth
    [ -f "$xauth_file" ] || die "no X authority file"
    [ -d "$xsock_dir"  ] || die "no X socket directory"
fi

if [ "$container_name" ]; then
    spawn_root_docker
elif [ "$root_dir" ]; then
    if [ "$container_type" = 'nspawn' ]; then
        spawn_root_nspawn
    else
        spawn_root_chroot
    fi
else
    die "container name or chroot directory is not specified"
fi
