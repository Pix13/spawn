#!/bin/sh

set -eu

program_name="spawn"

S=$(printf '\t')

root_dir=
container_type=
container_name=
container_user="dev"
container_home=
container_command=
passthrough_args=

root_arch=
with_ssh_agent=
with_pulseaudio=
with_x11=
bind_home=
chroot=
sts=0

this_runtime_dir=
runtime_dir=

xsock_dir='/tmp/.X11-unix'

show_usage() {
    cat <<EOF
Usage: $program_name [OPTIONS...] <name|directory> [--] [COMMAND [ARGS...]]

  Spawns new container or chroot and configures shared environment.

OPTIONS:

  -h|--help             Print this help message
  -r|--as-root          Use superuser inside the spawned root
  --user <name>         Assume <name> user inside the container
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as user home directory
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $xsock_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --umount-all          Release all mount points for the root directory
  --share-devices       Share devices with the host when chrooting
  --using-docker        Run command in a new Docker container
  --using-chroot        Change the root directory using chroot
  --unlock              Remove locks for the specified root directory

SYNOPSIS:

  Unknown options before <name|directory> are passed to the selected launcher
  as arguments (docker run, chroot, etc.). Everything else after
  <name|directory> and optional '--' are considered the command to be invoked
  inside the spawned container or chroot.

  Options starting with '--using' are mutually exclusive -- only the last one
  will have an effect. If none was given and the first non option argument
  specifies an existing directory then chroot will be assumed, otherwise the
  name will be passed to 'docker run'.

NOTE:

  If you get "Connection failure: Protocol error" error when trying to run
  PulseAudio applications inside the chroot, you need to disable communication
  through shared memory for the client. Add:

    enable-shm = no

  to "/etc/pulse/client.conf" inside the root-dir.

EOF
}

parse_command_line() {
    local parsing_command= eoa=

    while [ $# -gt 0 ]; do
        if [ "$parsing_command" ]; then
            container_command="${container_command}${S}${1}"
        else
            case $1 in
                --)
                    parsing_command=1 ;;
                -h|--help) show_usage; exit ;;
                -r|--as-root)
                    container_user='root' ;;
                -u|--user)
                    container_user="$2"; shift ;;
                --arch)
                    root_arch="$2"; shift ;;
                --bind-home)
                    bind_home="$2"; shift ;;
                --with-ssh-agent)
                    with_ssh_agent=1 ;;
                --with-x11)
                    with_x11=1 ;;
                --with-pulseaudio)
                    with_pulseaudio=1 ;;
                --umount-all)
                    umount_all=1 ;;
                --share-devices)
                    share_devices=1 ;;
                --using-docker)
                    container_type='docker' ;;
                --using-nspawn)
                    container_type='nspawn' ;;
                --using-chroot)
                    container_type='chroot' ;;
                --unlock)
                    do_unlock=1 ;;
                -*)
                    passthrough_args="${passthrough_args}${S}$1" ;;
                *)
                    case $container_type in
                        chroot|nspawn)
                            root_dir="$1" ;;
                        docker)
                            container_name="$1" ;;
                        '')
                            if [ -d "$1" ]; then
                                container_type="chroot"
                                root_dir="$1"
                            elif docker_image_exists "$1"; then
                                container_type="docker"
                                container_name="$1"
                            else
                                die "could not find an existing directory or an image with the name '$1'"
                            fi ;;
                    esac
                    parsing_command=1
                    # allow optional '--' after the first non-option argument
                    [ "${2-}" = '--' ] && shift
                    ;;
            esac
        fi
        shift
    done
}

validate_environment() {
    if [ -z "$root_dir" ] && [ -z "$container_name" ]; then
        die "root directory or image name to spawn is not specified"
    fi

    case $container_type in
        chroot|nspawn)
            [ "$root_dir" ] ||
                die "root directory is not specified"
            [ -d "$root_dir" ] ||
                die "the specified root directory '$root_dir' is not exists"
            [ -f "$root_dir/etc/passwd" ] ||
                die "/etc/passwd is not exists in '$root_dir'"
            user_exists "$container_user" ||
                die "the specified user '$container_user' is not found in '$root_dir'"
            ;;
        docker)
            [ "$container_name" ] ||
                die "container name is not specified"
            docker_image_exists "$container_name" ||
                die "the specified container image '$container_name' is not exists"
    esac

    case $container_type in
        nspawn)
            [ "$(command -v systemd-nspawn)" ] ||
                die "systemd-nspawn command was not found"
            ;;
        chroot)
            [ "$(command -v dirname)" ] ||
                die "dirname command was not found"
            [ "$(command -v realpath)" ] ||
                die "realpath command was not found"
            [ "$(command -v awk)" ] ||
                die "awk command was not found"
            [ "$(command -v tac)" ] ||
                die "tac command was not found"
            [ "$(command -v unshare)" ] ||
                die "unshare command was not found"

            chroot=$(command -v chroot)
            if [ -z "$chroot" ]; then
                chroot="/usr/sbin/chroot"
            fi
            if ! [ -x "$chroot" ]; then
                die "chroot command was not found"
            fi

            ;;
    esac

    case $container_type in
        nspawn|docker)
            if [ "${share_devices-}" ]; then
                die "the '--share-devices' option is valid only for chroot mode"
            fi ;;
    esac
}

die() {
    local status=$?
    [ $status = 0 ] && status=2
    [ $# = 0 ] || echo Error: $*
    exit $status
}

warn() {
    echo "Warning: $*"
}

su_run() {
    if [ "${UID-}" = "0" ]; then
        "$@"
    else
        sudo "$@"
    fi
}

escape_quote() {
    local arg= result=
    for arg; do
        arg=$(printf "%s" "$arg" | sed "s/'/'\\\''/g")
        result="$result${S}'$arg'"
    done
    printf '%s' "$result"
}

print_args() {
    printf "%d: " $#
    printf "<%s> " "$@"
    printf "\n"
}

docker_image_exists() {
    docker images | grep -q "^\b${1:?}\b"
}

user_exists() {
    grep -q "^$1:" "$root_dir/etc/passwd"
}

find_user_info() {
    local field="$1"
    if [ "$root_dir" ]; then
        [ -f "$root_dir/etc/passwd" ] || return
        while IFS=: read -r user pass uid gid gecos home shell; do
            if [ "$user" = "$container_user" ]; then
                eval "echo \$$field"
                break
            fi
        done < "$root_dir/etc/passwd"
    else
        case $container_user in
            root)
                case $field in
                     user) echo root ;;
                      uid) echo 0 ;;
                      gid) echo 0 ;;
                     home) echo /root ;;
                    shell) echo /bin/bash ;;
                esac ;;
            *)
                case $field in
                     user) echo $container_user ;;
                      uid) echo 1000 ;;
                      gid) echo 100  ;;
                     home) echo /home/$container_user ;;
                    shell) echo /bin/bash ;;
                esac ;;
        esac
    fi
}

get_my_config_dir() {
    echo "${XDG_CONFIG_HOME:-${HOME:?}/.config}${1:+/$1}"
}

get_config_dir() {
    local home_dir="$(find_user_info home)"
    local config_dir="${home_dir:?}/.config"

    echo "$config_dir${1:+/$1}"
}

get_my_runtime_dir() {
    echo "${XDG_RUNTIME_DIR:-/run/user/${UID:?}}${1:+/$1}"
}

get_runtime_dir() {
    local uid="$(find_user_info uid)"
    local runtime_dir="/run/user/${uid:?}"

    echo "$runtime_dir${1:+/$1}"
}

get_pa_socket() {
    if [ "$(command -v pactl)" ]; then
        pactl info 2>/dev/null | \
            awk '/Server String: / { print $3 }' | \
            sed 's/^unix://'
    fi
}

get_command() {
    local IFS="$S"
    case $container_type in
        chroot)
            if [ "$container_command" ]; then
                echo "$(escape_quote $container_command)"
            else
                echo "/bin/sh -c 'cd && exec /bin/bash -l'"
            fi ;;
        nspawn)
            if [ "$container_command" ]; then
                echo "$container_command"
            else
                echo "/bin/sh${S}-c${S}cd && exec /bin/bash -l"
            fi ;;
        docker)
            if [ "$container_command" ]; then
                echo "$container_command"
            fi ;;
    esac
}

in_mkdir() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o "$uid" -g "$gid" ${2:+"-m$2"} -d "$1" || die
}

get_lock_filename() {
    local dir="$(dirname "${1:?}")" name="$(basename "${1:?}")"
    echo "${dir:?}/.${program_name}.${name:?}.lock"
    # the scheme used by systemd-nspawn
    # echo "${dir}/.#${name}.lck"
}

is_locked() {
    test -f "$(get_lock_filename "${1:?}")"
}

lock_dir() {
    su_run touch "$(get_lock_filename "${1:?}")"
}

unlock_dir() {
    su_run rm -f "$(get_lock_filename "${1:?}")"
}

get_userspec_arg() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    echo "--userspec=$uid:$gid"
}

add_user_arg() {
    local _A= uid="$(find_user_info uid)"

    case $container_type in
        nspawn|docker)
            _A="--user=$uid" ;;
    esac

    eval "${1}=\"\$${1}$S$_A\""
}

make_setarch() {
    case $root_arch in
        x86|i?86)
            echo "linux32" ;;
        x86-64|x86_64|amd64)
            echo "linux64" ;;
    esac
}

make_env_arg() {
    local value="$1"
    case $container_type in
        chroot) echo "$value" ;;
        nspawn) echo "--setenv=$value" ;;
        docker) echo "--env=$value" ;;
    esac
}

make_bind_arg() {
    local value="$1"
    case $container_type in
        nspawn) echo "--bind=$value" ;;
        docker) echo "--volume=$value" ;;
    esac
}

setup_runtime_env() {
    local _A= uid= gid= config_dir=

    uid=$(find_user_info uid); : ${uid:?}
    gid=$(find_user_info gid); : ${gid:?}

    config_dir=$(get_config_dir); : ${config_dir:?}

    this_runtime_dir=$(mktemp -dp "$(get_my_runtime_dir)" spawn.XXXXXXXXXX)
    : ${this_runtime_dir:?}
    runtime_dir=$(get_runtime_dir); : ${runtime_dir:?}

    su_run mount -t tmpfs -o uid=$uid,gid=$gid,mode=700 tmpfs "$this_runtime_dir"

    case $container_type in
        chroot)
            _A="$_A$S$(make_env_arg TERM=$TERM)"
            _A="$_A$S$(make_env_arg HOME=$container_home)"
            _A="$_A$S$(make_env_arg USER=$container_user)"
            _A="$_A$S$(make_env_arg LOGNAME=$container_user)"

            if [ "$container_user" = "root" ]; then
                _A="$_A$S$(make_env_arg PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin)"
            else
                _A="$_A$S$(make_env_arg PATH=/usr/local/bin:/usr/bin:/bin)"
            fi

            in_mkdir "$root_dir$runtime_dir"
            ;;
        *)
            _A="$_A$S$(make_bind_arg $this_runtime_dir:$runtime_dir)"
            ;;

    esac

    _A="$_A$S$(make_env_arg "XDG_CONFIG_HOME=$config_dir")"
    _A="$_A$S$(make_env_arg "XDG_RUNTIME_DIR=$runtime_dir")"

    if [ "$root_dir" ]; then
        in_mkdir "$root_dir/$config_dir"
    fi

    eval "${1}=\"\$${1}$S$_A\""
}

setup_system_env() {
    local SYS_A=

    case $container_type in
        chroot)
            su_run touch "$root_dir/etc/resolv.conf"
            su_run mount --bind "/etc/resolv.conf" "$root_dir/etc/resolv.conf"
            ;;
        nspawn)
            SYS_A="$SYS_A$S$(make_bind_arg "/etc/resolv.conf:/etc/resolv.conf")"
            ;;
    esac

    if [ -f /etc/localtime ]; then
        case $container_type in
            chroot)
                su_run touch "$root_dir/etc/localtime"
                su_run mount --bind "/etc/localtime" "$root_dir/etc/localtime"
                ;;
            nspawn)
                SYS_A="$SYS_A$S$(make_bind_arg "/etc/localtime:/etc/localtime")"
                ;;
        esac
    fi

    eval "${1}=\"\$${1}$S$SYS_A\""
}

setup_ssh_env() {
    local SSH_A= uid=

    [ "${with_ssh_agent-}" ] || return 0

    [ "${SSH_AUTH_SOCK-}" ] ||
        die "passing of SSH agent is enabled but SSH_AUTH_SOCK is not set"
    [ -S "$SSH_AUTH_SOCK" ] ||
        die "$SSH_AUTH_SOCK socket is not exists or is not a socket"

    uid=$(find_user_info uid); : ${uid:?}

    SSH_A="$SSH_A$S$(make_env_arg "SSH_AUTH_SOCK=$runtime_dir/ssh")"

    case $container_type in
        chroot)
            su_run touch "$this_runtime_dir/ssh"
            su_run mount --bind "$SSH_AUTH_SOCK" "$this_runtime_dir/ssh"
            ;;
        *)
            SSH_A="$SSH_A$S$(make_bind_arg "$SSH_AUTH_SOCK:$runtime_dir/ssh")"
            ;;
    esac

    if [ "$UID" != "$uid" ]; then
        warn "current UID ($UID) does not match UID inside the container \
($uid) but SSH agent socket sharing is requested -- changing $SSH_AUTH_SOCK \
mode to world writeable/readable (666)"
        su_run chmod 666 "$SSH_AUTH_SOCK"
    fi

    eval "${1}=\"\$${1}$S$SSH_A\""
}

setup_x11_env() {
    local X11_A= xauth_file=

    [ "${with_x11-}" ] || return 0

    [ "${DISPLAY-}" ] ||
        die "passing of X11 environment is enabled but DISPLAY is not set"
    [ -d "$xsock_dir" ] ||
        die "X11 socket directory '$xsock_dir' is not exists"

    xauth_file="$this_runtime_dir/Xauthority"
    su_run touch "$xauth_file"
    extract_xauth "$xauth_file"
    su_run chmod 666 "$xauth_file"

    X11_A="$X11_A$S$(make_env_arg "DISPLAY=$DISPLAY")"
    X11_A="$X11_A$S$(make_env_arg "XAUTHORITY=$runtime_dir/Xauthority")"

    # disable Qt's usage of shared memory which we do not expose
    X11_A="$X11_A$S$(make_env_arg QT_X11_NO_MITSHM=1)"

    # Exposing whole X11 socket directory is probably a bad idea, hopefully
    # assuming that most users are running single X11 instance.

    case $container_type in
        chroot)
            su_run mkdir -p "$root_dir$xsock_dir"
            su_run mount --bind "$xsock_dir" "$root_dir$xsock_dir"
            ;;
        *)
            X11_A="$X11_A$S$(make_bind_arg "$xsock_dir:$xsock_dir")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$X11_A\""
}

setup_pa_env() {
    local PA_A= sock_file= cookie_file=

    [ "${with_pulseaudio-}" ] || return 0

    sock_file=$(get_pa_socket)

    [ "$sock_file" ] ||
        die "passing of PulseAudio is enabled but the socket could not be found"
    [ -S "$sock_file" ] ||
        die "PulseAudio socket '$sock_file' is not exists or is not a socket"

    cookie_file=$(get_my_config_dir pulse)/cookie
    [ -f "$cookie_file" ] ||
        die "PulseAudio cookie file '$cookie_file' is not found"
    su_run cp "$cookie_file" "$this_runtime_dir/pulse_cookie"
    su_run chmod 666 "$this_runtime_dir/pulse_cookie"

    PA_A="$PA_A$S$(make_env_arg "PULSE_SERVER=$runtime_dir/pulse_sock")"
    PA_A="$PA_A$S$(make_env_arg "PULSE_COOKIE=$runtime_dir/pulse_cookie")"

    case $container_type in
        chroot)
            su_run touch "$this_runtime_dir/pulse_sock"
            su_run mount --bind "$sock_file" "$this_runtime_dir/pulse_sock"
            ;;
        *)
            PA_A="$PA_A$S$(make_bind_arg "$sock_file:$runtime_dir/pulse_sock")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$PA_A\""
}

setup_home_env() {
    local HOME_A=

    [ "$bind_home" ] || return 0

    [ -d "$bind_home" ] ||
        die "The directory '$bind_home' is not exists"

    if [ "$root_dir" ]; then
        in_mkdir "$root_dir/$container_home"
    fi

    if [ "$container_type" = "chroot" ]; then
        su_run mount --bind "$bind_home" "$root_dir/$container_home"
    else
        HOME_A="$HOME_A$S$(make_bind_arg "$bind_home:$container_home")"
    fi

    eval "${1}=\"\$${1}$S$HOME_A\""
}

setup_env() {
    add_user_arg      "$1"
    setup_runtime_env "$1"
    setup_system_env  "$1"
    setup_ssh_env     "$1"
    setup_x11_env     "$1"
    setup_pa_env      "$1"
    setup_home_env    "$1"
}

extract_xauth() {
    # Use wildcard authentication family because hostname of container can
    # differ from the host and default Xauthority files are hostname specific.
    # See http://stackoverflow.com/a/25280523 for details.
    xauth nlist "$DISPLAY" | sed 's/^..../ffff/' | su_run xauth -f "$1" nmerge -
}

umount_all() {
    local IFS="$(printf '\n\t')" root= mp=

    [ "$root_dir" ] || return 0

    unlock_dir "$root_dir"

    if [ "$container_type" = 'chroot' ]; then
        root="$(realpath "$root_dir")"
        for mp in $(awk -v i="$root" '$2~i {print $2}' /proc/mounts | tac)
        do
            su_run umount "$mp" || true
        done
    fi
}

cleanup() {
    local root= path=

    if [ "$root_dir" ]; then
        root=$(realpath "$root_dir")
        for path in $(awk -v r="^$root" '$2~r {print $2}' /proc/mounts | sort -r); do
            su_run umount "$path"
        done
    fi

    if [ "$this_runtime_dir" ]; then
        su_run mountpoint -q "$this_runtime_dir" && \
            su_run umount -R "$this_runtime_dir" || true
        su_run rm -rf "$this_runtime_dir" || true
    fi
}

spawn_root_chroot() {
    local IFS="$S" env= cmd=

    trap cleanup EXIT

    setup_env env

    cmd=$(cat <<EOF
set -e
mount -t proc proc "${root_dir}/proc"
EOF
)

    if [ "${share_devices-}" ]; then
        su_run mkdir -p "$root_dir/dev" "$root_dir/sys"
        su_run mount --rbind /dev "$root_dir/dev"
        su_run mount --make-rslave "$root_dir/dev"
        su_run mount --rbind /sys "$root_dir/sys"
        su_run mount --make-rslave "$root_dir/sys"
    else
        cmd="$cmd; $(cat <<EOF
mount -t tmpfs -o nosuid tmpfs "$root_dir/dev"
mkdir -p "$root_dir/dev/shm" "$root_dir/dev/pts"
mount -t tmpfs -o nosuid,nodev shm "$root_dir/dev/shm"
mount -t devpts -o nosuid,noexec,gid=5,mode=620,ptmxmode=666,newinstance devpts "$root_dir/dev/pts"
ln -snf pts/ptmx "$root_dir/dev/ptmx"
ln -snf /proc/self/fd "$root_dir/dev/fd"
ln -snf /proc/self/fd/0 "$root_dir/dev/stdin"
ln -snf /proc/self/fd/1 "$root_dir/dev/stdout"
ln -snf /proc/self/fd/2 "$root_dir/dev/stderr"
mknod "$root_dir/dev/null" c 1 3
mknod "$root_dir/dev/zero" c 1 5
mknod "$root_dir/dev/random" c 1 8
mknod "$root_dir/dev/urandom" c 1 9
mknod "$root_dir/dev/console" c 5 1
mknod "$root_dir/dev/tty" c 5 0
chmod 666 "$root_dir/dev/null" "$root_dir/dev/zero" "$root_dir/dev/random" \
    "$root_dir/dev/urandom" "$root_dir/dev/tty"
chmod 600 "$root_dir/dev/console"
mount -t sysfs sysfs "$root_dir/sys"
EOF
)"
    fi

    cmd="$cmd; $(cat <<EOF
mount --rbind "$this_runtime_dir" "$root_dir$runtime_dir"
$chroot $(get_userspec_arg) "$root_dir" $(get_command)
EOF
)"

    su_run $(make_setarch) env - $env unshare -mpf /bin/sh -c "$cmd"
}

spawn_root_nspawn() {
    local IFS="$S" A=

    trap cleanup EXIT

    # systemd-nspawn runs 'getent passwd <user>' inside the container to get
    # passwd entry for the user or fails with "Failed to resolve user <user>"

    setup_env A

    su_run systemd-nspawn $A $passthrough_args -D "$root_dir" -- $(get_command)
}

spawn_root_docker() {
    local IFS="$S" A= cmd=

    trap cleanup EXIT

    setup_env A

    docker run --rm -it $A $passthrough_args $container_name $(get_command)
}

if [ $# = 0 ]; then
    show_usage
    exit
fi

parse_command_line "$@"
validate_environment

if [ "${do_unlock-}" ]; then
    if [ "$root_dir" ]; then
        unlock_dir "$root_dir"
    fi
    exit
fi

if [ "${umount_all-}" ]; then
    umount_all
    exit
fi

container_home=$(find_user_info home)
[ "$container_home" ] ||
    die "failed to find user's home directory"

if [ "$container_name" ]; then
    spawn_root_docker
elif [ "$root_dir" ]; then
    if is_locked "$root_dir"; then
        die "the directory '$root_dir' may be already in use by another spawn \
instance, use '--unlock' option first to override"
    fi
    lock_dir "$root_dir"

    if [ "$container_type" = 'nspawn' ]; then
        spawn_root_nspawn || sts=$?
    else
        spawn_root_chroot || sts=$?
    fi

    # to make sure the cleanup is finished before the dir is unlocked
    trap - EXIT
    cleanup

    unlock_dir "$root_dir"
    sync

    exit $sts
else
    die "container name or chroot directory is not specified"
fi
