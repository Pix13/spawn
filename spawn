#!/bin/sh

set -u

program_name="spawn"

S=$(printf '\t')

root_dir=
container_type=
container_name=
container_user="dev"
container_group="users"
container_home="/home/$container_user"
container_command=
additional_args=

root_arch=
with_ssh_agent=
with_pulseaudio=
with_x11=
cleanup_only=
share_system=
bind_home=

xauth_file=
xsock_dir='/tmp/.X11-unix'

show_usage() {
    cat <<EOF
Usage: $program_name [OPTIONS...] <name|directory> [--] [COMMAND [ARGS...]]

  Spawns new container or chroot and configures shared environment.

OPTIONS:

  -h|--help             Print this help message
  -r|--as-root          Use superuser inside the spawned root
  --user <name>         Assume <name> user inside the container
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as user home directory
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $xsock_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --cleanup             Execute cleanup procedures only
  --using-docker        Run command in a new Docker container
  --using-chroot        Change the root directory using chroot

SYNOPSIS:

  Unknown options before <name|directory> are passed to the selected launcher
  as arguments (docker run, chroot, etc.). Everything else after
  <name|directory> and optional '--' are considered the command to be invoked
  inside the spawned container or chroot.

  Options starting with '--using' are mutually exclusive -- only the last one
  will have an effect. If none was given and the first non option argument
  specifies an existing directory then chroot will be assumed, otherwise the
  name will be passed to 'docker run'.

EOF
}

parse_command_line() {
    local parsing_command= eoa=

    while [ $# -gt 0 ]; do
        if [ "$parsing_command" ]; then
            container_command="${container_command}${S}${1}"
        else
            case $1 in
                --)
                    parsing_command=1 ;;
                -h|--help) show_usage; exit ;;
                -r|--as-root)
                    container_user='root' ;;
                -u|--user)
                    container_user="$2"; shift ;;
                --arch)
                    root_arch="$2"; shift ;;
                --bind-home)
                    bind_home="$2"; shift ;;
                --with-ssh-agent)
                    with_ssh_agent=1 ;;
                --with-x11)
                    with_x11=1 ;;
                --with-pulseaudio)
                    with_pulseaudio=1 ;;
                --cleanup)
                    cleanup_only=1 ;;
                --share-system)
                    share_system=1 ;;
                --boot)
                    spawn_boot=1 ;;
                --using-docker)
                    container_type='docker' ;;
                --using-nspawn)
                    container_type='nspawn' ;;
                --using-chroot)
                    container_type='chroot' ;;
                -*)
                    additional_args="${additional_args}${S}$1" ;;
                *)
                    if [ -d "$1" ]; then
                        container_type="${container_type:-chroot}"
                        root_dir="$1"
                    else
                        container_type="${container_type:-docker}"
                        container_name="$1"
                    fi
                    parsing_command=1
                    # allow optional '--' after the first non-option argument
                    [ "${2-}" = '--' ] && shift
                    ;;
            esac
        fi
        shift
    done
}

validate_environment() {
    [ "$container_type" ] ||
        die "unable to determine container type from the arguments"
    case $container_type in
        docker)
            [ "$container_name" ] ||
                die "container name was not specified"
            ;;
        nspawn)
            ;;
        chroot)
            [ "$root_dir" ] ||
                die "root directory was not specified"
            [ -d "$root_dir" ] ||
                die "root directory '$root_dir' is not exists"
            [ "$(command -v dirname)" ] ||
                die "dirname command was not found"
            [ "$(command -v realpath)" ] ||
                die "realpath command was not found"
            [ "$(command -v awk)" ] ||
                die "awk command was not found"
            [ "$(command -v tac)" ] ||
                die "tac command was not found"
            [ "$(command -v unshare)" ] ||
                die "unshare command was not found"

            chroot=$(command -v chroot)
            [ "$chroot" ] ||
                chroot="/usr/sbin/chroot"
            [ -x "$chroot" ] ||
                die "chroot command was not found"
            ;;
        *)
            die "unsupported container type: $container_type"
            ;;
    esac

    if [ "$bind_home" ]; then
        [ -d "$bind_home" ] ||
            die "The directory '$bind_home' is not exists"
    fi

    if [ "$with_ssh_agent" ]; then
        [ "$SSH_AUTH_SOCK" ] ||
            die "SSH_AUTH_SOCK is not set"
        [ -e "$SSH_AUTH_SOCK" ] ||
            die "$SSH_AUTH_SOCK is not exists"
    fi

    if [ "$with_x11" ]; then
        [ "$DISPLAY" ] ||
            die "passing of X11 environment is enabled but DISPLAY is not set"
        [ -d "$xsock_dir" ] ||
            die "X11 socket directory '$xsock_dir' is not exists"
    fi
}

die() {
    local status=$?
    [ $status = 0 ] && status=2
    [ $# = 0 ] || echo Error: $*
    exit $status
}

su_run() {
    if [ "${UID-}" = "0" ]; then
        "$@"
    else
        sudo "$@"
    fi
}

try_source() { [ -f "$1" ] && . "$1" || :; }

escape_quote() {
    local arg= result=
    for arg in "$@"; do
        arg=$(printf "%s" "$arg" | sed "s/'/'\\\''/g")
        result="$result${S}'$arg'"
    done
    echo "$result"
}

print_args() {
    printf "%d: " $#
    printf "<%s> " "$@"
    printf "\n"
}

load_config() {
    if [ "${XDG_CONFIG_HOME-}" ]; then
        try_source "$XDG_CONFIG_HOME/$program_name/env"
    else
        try_source "$HOME/.config/$program_name/env"
    fi
}

passwd_exists() {
    test -f "$root_dir/etc/passwd"
}

user_exists() {
    grep -q "^$1:" "$root_dir/etc/passwd"
}

find_user_info() {
    local field="$1"
    if [ "$root_dir" ]; then
        [ -f "$root_dir/etc/passwd" ] || return
        while IFS=: read -r user pass uid gid gecos home shell; do
            if [ "$user" = "$container_user" ]; then
                eval "echo \$$field"
                break
            fi
        done < "$root_dir/etc/passwd"
    else
        case $container_user in
            root)
                case $field in
                     user) echo root ;;
                      uid) echo 0 ;;
                      gid) echo 0 ;;
                     home) echo /root ;;
                    shell) echo /bin/bash ;;
                esac ;;
            *)
                case $field in
                     user) echo $container_user ;;
                      uid) echo 1000 ;;
                      gid) echo 100  ;;
                     home) echo /home/$container_user ;;
                    shell) echo /bin/bash ;;
                esac ;;
        esac
    fi
}

get_userspec() {
    local uid= gid=
    uid=$(find_user_info uid)
    gid=$(find_user_info gid)
    echo "$uid:$gid"
}

set_container_home() {
    if [ "$container_user" = 'root' ]; then
        container_home="/root"
    else
        container_home="/home/$container_user"
    fi
}

in_mkdir() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o $uid -g $gid -d "$1" || die
}

in_touch() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o "$uid" -g "$gid" -d "$(dirname "$1")" || die
    su_run touch "$1" || die
    su_run chown "$uid:$gid" "$1" || die
}

in_mount() {
    su_run mount "$@" || die
}

make_env_arg() {
    local value="$1"
    case $container_type in
        chroot) ;;
        nspawn) echo "--setenv=$value" ;;
        docker) echo "--env=$value" ;;
    esac
}

make_bind_arg() {
    local value="$1"
    case $container_type in
        chroot) ;;
        nspawn) echo "--bind=$value" ;;
        docker) echo "--volume=$value" ;;
    esac
}

make_ssh_args() {
    local A=

    A="$A$S$(make_env_arg "SSH_AUTH_SOCK=$SSH_AUTH_SOCK")"
    A="$A$S$(make_bind_arg "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK")"

    echo "$A"
}

make_x11_args() {
    local A=

    A="$A$S$(make_env_arg "DISPLAY=$DISPLAY")"
    A="$A$S$(make_env_arg "XAUTHORITY=$xauth_file")"

    # disable Qt's usage of shared memory which we do not expose
    A="$A$S$(make_env_arg QT_X11_NO_MITSHM=1)"

    A="$A$S$(make_bind_arg "$xauth_file:$xauth_file")"
    A="$A$S$(make_bind_arg "$xsock_dir:$xsock_dir")"

    echo "$A"
}

make_pa_args() {
    local A= pa_sock= in_pa_sock=

    pa_sock=$(get_pa_socket)
    validate_pa_socket "$pa_sock"
    in_pa_sock="$(get_in_pa_socket)"

    A="$A$S$(make_env_arg "PULSE_SERVER=$in_pa_sock")"
    A="$A$S$(make_bind_arg "$pa_sock:$in_pa_sock")"

    # copy_pa_cookie

    echo "$A"
}

get_config_dir() {
    local config_dir="/home/$container_user/.config"

    echo "$config_dir${1:+/$1}"
}

get_runtime_dir() {
    local uid="$(find_user_info uid)"
    local runtime_dir="/run/user/${uid:?}"

    echo "$runtime_dir${1:+/$1}"
}

get_pa_socket() {
    if [ "$(command -v pactl)" ]; then
        pactl info 2>/dev/null | \
            awk '/Server String: / { print $3 }' | \
            sed 's/^unix://'
    fi
}

get_in_pa_socket() {
    echo "$(get_runtime_dir pulse)/native"
}

validate_pa_socket() {
    [ -S "$1" ] || die "PulseAudio socket '$1' does not exist"
}

copy_pa_cookie() {
    local cookie_file="$HOME/.config/pulse/cookie"
    local dest_dir="$root_dir/$(get_config_dir pulse)"
    [ -f "$cookie_file" ] || die "PulseAudio cookie file '$cookie_file' was not found"
    in_mkdir "$dest_dir"
    su_run cp -f "$cookie_file" "$dest_dir/cookie" || die
    su_run chown "$(get_userspec)" "$dest_dir/cookie" || die
}

extract_xauth() {
    xauth_file=$(mktemp)
    # Use wildcard authentication family because hostname of container can
    # differ from the host and default Xauthority files are hostname specific.
    # See http://stackoverflow.com/a/25280523 for details.
    xauth nlist "$DISPLAY" | sed 's/^..../ffff/' | xauth -f "$xauth_file" nmerge -
}

copy_resolv_conf() {
    su_run cp -L /etc/resolv.conf "$root_dir/etc/resolv.conf" ||
        die "failed to copy resolv.conf"
}

fix_mtab() {
    if [ ! -h "$root_dir/etc/mtab" ]; then
        su_run ln -sf /proc/self/mounts "$root_dir/etc/mtab" ||
            die "failed to link mtab"
    fi
}

cleanup() {
    local root=

    if [ "$container_type" = 'chroot' ]; then
        root="$(realpath "$root_dir")"
        for mp in $(awk -v i="$root" '$2~i {print $2}' /proc/mounts | tac)
        do
            su_run umount "$mp" || true
        done
    fi
}

spawn_root_nspawn() {
    local IFS="$S"
    local A= pa_sock= in_pa_sock= cmd=

    # systemd-nspawn runs 'getent passwd <user>' inside the container to get
    # passwd entry for the user or fails with "Failed to resolve user <user>"
    if [ "$container_user" ]; then
        A="$A$S--user=$container_user"
    fi

    if ! passwd_exists || ! user_exists "$container_user"; then
        die "the specified user '$container_user' is not found inside the chroot"
    fi

    if [ "$share_system" ]; then
        A="$A$S--share-system"
    fi

    if [ "$bind_home" ]; then
        container_home=$(find_user_info home)
        [ "$container_home" ] ||
            die "failed to find user's home directory"
        su_run mkdir -p "$root_dir/$container_home" || die
        A="$A$S--bind=$bind_home:$container_home"
    fi

    if [ "$with_ssh_agent" ]; then
        A="$A$S$(make_ssh_args)"
    fi

    if [ "$with_x11" ]; then
        A="$A$S$(make_x11_args)"
    fi

    if [ "$with_pulseaudio" ]; then
        A="$A$S$(make_pa_args)"
    fi

    if [ "${spawn_boot-}" ]; then
        A="$A$S--boot"
    fi

    if [ "${container_command-}" ]; then
        cmd="$container_command"
    else
        cmd="/bin/sh${S}-c${S}cd && exec /bin/bash -l"
    fi

    su_run systemd-nspawn $A $additional_args -D "$root_dir" $cmd
}

spawn_root_chroot() {
    local IFS="$S"
    local userspec= path= setarch= env= ssh_sock_dir=
    local cmd= mount_cmd= chroot_cmd= i=
    local pa_sock= in_pa_sock=

    if [ "$container_user" = 'root' ]; then
        userspec="0:0"
        path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    else
        userspec="$container_user:users"
        path="/usr/local/bin:/usr/bin:/bin"
    fi

    if ! passwd_exists || ! user_exists "$container_user"; then
        die "the specified user '$container_user' is not found inside the chroot"
    fi

    container_home="$(find_user_info home)"

    case $root_arch in
        x86|i?86)
            setarch="linux32" ;;
        x86-64|x86_64|amd64)
            setarch="linux64" ;;
    esac

    mount_cmd="mount -t proc proc \"$root_dir/proc\" &&"

    if [ "$share_system" ]; then
        su_run mkdir -p "$root_dir/sys"            || die
        su_run mount --rbind /sys "$root_dir/sys"  || die
        su_run mount --make-rslave "$root_dir/sys" || die
        su_run mkdir -p "$root_dir/dev"            || die
        su_run mount --rbind /dev "$root_dir/dev"  || die
        su_run mount --make-rslave "$root_dir/dev" || die
    else
        if [ -h "$root_dir/dev/shm" ]; then
            su_run rm "$root_dir/dev/shm"
        fi
        su_run mkdir -p "$root_dir/dev/shm" "$root_dir/dev/pts"

        mount_cmd="$mount_cmd $(cat <<EOF
mount -t tmpfs -o nosuid,nodev,noexec shm "$root_dir/dev/shm" && \
mount -t devpts -o nosuid,noexec,gid=5,mode=620 devpts "$root_dir/dev/pts" &&
EOF
)"
    fi

    if [ "$bind_home" ]; then
        container_home=$(find_user_info home)
        [ "$container_home" ] ||
            die "failed to find user's home directory"
        su_run mkdir -p "$root_dir/$container_home" || die
        su_run mount --bind "$bind_home" "$root_dir/$container_home" || die
    fi

    env="${env}${S}TERM=$TERM"
    env="${env}${S}HOME=$container_home"
    env="${env}${S}USER=$container_user"
    env="${env}${S}LOGNAME=$container_user"
    env="${env}${S}PATH=$path"

    if [ "$with_ssh_agent" ]; then
        env="${env}${S}SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
        ssh_sock_dir=$(dirname "$SSH_AUTH_SOCK")
        su_run mkdir -p "$root_dir/$ssh_sock_dir" || die
        su_run mount --bind "$ssh_sock_dir" "$root_dir/$ssh_sock_dir" || die
    fi

    if [ "$with_x11" ]; then
        env="${env}${S}DISPLAY=$DISPLAY"
        env="${env}${S}XAUTHORITY=$xauth_file"
        su_run mkdir -p "$root_dir/$xsock_dir" || die
        su_run mkdir -p "$root_dir/$(dirname $xauth_file)" || die
        su_run mount --bind "$xsock_dir" "$root_dir/$xsock_dir" || die
        su_run cp -a --parents "$xauth_file" "$root_dir" || die
    fi

    if [ "$with_pulseaudio" ]; then
        pa_sock=$(get_pa_socket)
        validate_pa_socket "$pa_sock"
        in_pa_sock="$(get_in_pa_socket)"
        env="${env}${S}PULSE_SERVER=$in_pa_sock"
        in_touch "$root_dir/$in_pa_sock"
        su_run mount --bind "$pa_sock" "$root_dir/$in_pa_sock" || die
        copy_pa_cookie
    fi

    if [ "${container_command-}" ]; then
        cmd=$(escape_quote $container_command)
    else
        cmd="/bin/sh${S}-c${S}'cd && exec /bin/bash -l'"
    fi

    chroot_cmd="\"$chroot\" --userspec=\"$userspec\" \"$root_dir\""

    mount_cmd="$mount_cmd $chroot_cmd $cmd"

    su_run $setarch env - $env unshare -m /bin/sh -c "$mount_cmd"
}

spawn_root_docker() {
    local IFS="$(printf '\n\t')"
    local A= pa_sock= in_pa_sock=

    A="--user=$container_user"

    if [ "$bind_home" ]; then
        A="${A}${S}--volume=$bind_home:$container_home"
    fi

    if [ "$with_ssh_agent" ]; then
        A="$A$S$(make_ssh_args)"
    fi

    if [ "$with_x11" ]; then
        A="$A$S$(make_x11_args)"
    fi

    if [ "$with_pulseaudio" ]; then
        A="$A$S$(make_pa_args)"
    fi

    docker run --rm -it \
        ${share_system:+--privileged} \
        $A $additional_args $container_name \
        $container_command
}

if [ $# = 0 ]; then
    show_usage
    exit
fi

load_config

parse_command_line "$@"
validate_environment

if [ "$cleanup_only" ]; then
    cleanup
    exit
fi

set_container_home

trap cleanup EXIT

if [ "$with_x11" ]; then
    extract_xauth
    [ -f "$xauth_file" ] || die "no X authority file"
    [ -d "$xsock_dir"  ] || die "no X socket directory"
fi

if [ "$container_name" ]; then
    spawn_root_docker
elif [ "$root_dir" ]; then
    if [ "$container_type" = 'nspawn' ]; then
        spawn_root_nspawn
    else
        spawn_root_chroot
    fi
else
    die "container name or chroot directory is not specified"
fi
