#!/bin/sh

set -u

program_name="spawn"

S=$(printf '\t')

root_dir=
container_type=
container_name=
container_user="dev"
container_group="users"
container_home=
container_command=
passthrough_args=

root_arch=
with_ssh_agent=
with_pulseaudio=
with_x11=
cleanup_only=
share_system=
bind_home=
chroot=

xauth_file=
xsock_dir='/tmp/.X11-unix'

show_usage() {
    cat <<EOF
Usage: $program_name [OPTIONS...] <name|directory> [--] [COMMAND [ARGS...]]

  Spawns new container or chroot and configures shared environment.

OPTIONS:

  -h|--help             Print this help message
  -r|--as-root          Use superuser inside the spawned root
  --user <name>         Assume <name> user inside the container
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as user home directory
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $xsock_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --cleanup             Execute cleanup procedures only
  --share-system        Share dev and sys with the host
  --using-docker        Run command in a new Docker container
  --using-chroot        Change the root directory using chroot

SYNOPSIS:

  Unknown options before <name|directory> are passed to the selected launcher
  as arguments (docker run, chroot, etc.). Everything else after
  <name|directory> and optional '--' are considered the command to be invoked
  inside the spawned container or chroot.

  Options starting with '--using' are mutually exclusive -- only the last one
  will have an effect. If none was given and the first non option argument
  specifies an existing directory then chroot will be assumed, otherwise the
  name will be passed to 'docker run'.

EOF
}

parse_command_line() {
    local parsing_command= eoa=

    while [ $# -gt 0 ]; do
        if [ "$parsing_command" ]; then
            container_command="${container_command}${S}${1}"
        else
            case $1 in
                --)
                    parsing_command=1 ;;
                -h|--help) show_usage; exit ;;
                -r|--as-root)
                    container_user='root' ;;
                -u|--user)
                    container_user="$2"; shift ;;
                --arch)
                    root_arch="$2"; shift ;;
                --bind-home)
                    bind_home="$2"; shift ;;
                --with-ssh-agent)
                    with_ssh_agent=1 ;;
                --with-x11)
                    with_x11=1 ;;
                --with-pulseaudio)
                    with_pulseaudio=1 ;;
                --cleanup)
                    cleanup_only=1 ;;
                --share-system)
                    share_system=1 ;;
                --using-docker)
                    container_type='docker' ;;
                --using-nspawn)
                    container_type='nspawn' ;;
                --using-chroot)
                    container_type='chroot' ;;
                -*)
                    passthrough_args="${passthrough_args}${S}$1" ;;
                *)
                    if [ -d "$1" ]; then
                        container_type="${container_type:-chroot}"
                        root_dir="$1"
                    else
                        container_type="${container_type:-docker}"
                        container_name="$1"
                    fi
                    parsing_command=1
                    # allow optional '--' after the first non-option argument
                    [ "${2-}" = '--' ] && shift
                    ;;
            esac
        fi
        shift
    done
}

validate_environment() {
    if [ -z "$container_type" ]; then
        die "unable to determine container type from the arguments, probably \
no name or directory was given or the specified directory does not exist"
    fi

    case $container_type in
        chroot|nspawn)
            [ "$root_dir" ] ||
                die "root directory is not specified"
            [ -d "$root_dir" ] ||
                die "root directory '$root_dir' is not exists"
            [ -f "$root_dir/etc/passwd" ] ||
                die "/etc/passwd is not exists in '$root_dir'"
            user_exists "$container_user" ||
                die "the specified user '$container_user' is not found in '$root_dir'"
            ;;
        docker)
            [ "$container_name" ] ||
                die "container name is not specified"
    esac

    case $container_type in
        nspawn)
            [ "$(command -v systemd-nspawn)" ] ||
                die "systemd-nspawn command was not found"
            ;;
        chroot)
            [ "$(command -v dirname)" ] ||
                die "dirname command was not found"
            [ "$(command -v realpath)" ] ||
                die "realpath command was not found"
            [ "$(command -v awk)" ] ||
                die "awk command was not found"
            [ "$(command -v tac)" ] ||
                die "tac command was not found"
            [ "$(command -v unshare)" ] ||
                die "unshare command was not found"

            chroot=$(command -v chroot)
            if [ -z "$chroot" ]; then
                chroot="/usr/sbin/chroot"
            fi
            if ! [ -x "$chroot" ]; then
                die "chroot command was not found"
            fi

            ;;
    esac
}

die() {
    local status=$?
    [ $status = 0 ] && status=2
    [ $# = 0 ] || echo Error: $*
    exit $status
}

warn() {
    echo "Warning: $*"
}

su_run() {
    if [ "${UID-}" = "0" ]; then
        "$@"
    else
        sudo "$@"
    fi
}

escape_quote() {
    local arg= result=
    for arg in "$@"; do
        arg=$(printf "%s" "$arg" | sed "s/'/'\\\''/g")
        result="$result${S}'$arg'"
    done
    echo "$result"
}

print_args() {
    printf "%d: " $#
    printf "<%s> " "$@"
    printf "\n"
}

user_exists() {
    grep -q "^$1:" "$root_dir/etc/passwd"
}

find_user_info() {
    local field="$1"
    if [ "$root_dir" ]; then
        [ -f "$root_dir/etc/passwd" ] || return
        while IFS=: read -r user pass uid gid gecos home shell; do
            if [ "$user" = "$container_user" ]; then
                eval "echo \$$field"
                break
            fi
        done < "$root_dir/etc/passwd"
    else
        case $container_user in
            root)
                case $field in
                     user) echo root ;;
                      uid) echo 0 ;;
                      gid) echo 0 ;;
                     home) echo /root ;;
                    shell) echo /bin/bash ;;
                esac ;;
            *)
                case $field in
                     user) echo $container_user ;;
                      uid) echo 1000 ;;
                      gid) echo 100  ;;
                     home) echo /home/$container_user ;;
                    shell) echo /bin/bash ;;
                esac ;;
        esac
    fi
}

get_config_dir() {
    local home_dir="$(find_user_info home)"
    local config_dir="${home_dir:?}/.config"

    echo "$config_dir${1:+/$1}"
}

get_runtime_dir() {
    local uid="$(find_user_info uid)"
    local runtime_dir="/run/user/${uid:?}"

    echo "$runtime_dir${1:+/$1}"
}

get_pa_socket() {
    if [ "$(command -v pactl)" ]; then
        pactl info 2>/dev/null | \
            awk '/Server String: / { print $3 }' | \
            sed 's/^unix://'
    fi
}

get_command() {
    case $container_type in
        chroot)
            if [ "$container_command" ]; then
                echo "$(escape_quote $container_command)"
            else
                echo "/bin/sh${S}-c${S}'cd && exec /bin/bash -l'"
            fi ;;
        nspawn)
            if [ "$container_command" ]; then
                echo "$container_command"
            else
                echo "/bin/sh${S}-c${S}cd && exec /bin/bash -l"
            fi ;;
        docker)
            if [ "$container_command" ]; then
                echo "$container_command"
            fi ;;
    esac
}

in_mkdir() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o "$uid" -g "$gid" ${2:+"-m$2"} -d "$1" || die
}

in_touch() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    su_run install -o "$uid" -g "$gid" -d "$(dirname "$1")" || die
    su_run touch "$1" || die
    su_run chown "$uid:$gid" "$1" || die
}

in_mount() {
    su_run mount "$@" || die
}

in_mount2() {
    local from="${1:-?}" to="${2:-?}"
    shift 2
    if [ -d "$from" ]; then
        in_mkdir "$to"
    else
        in_touch "$to"
    fi
    su_run mount "$@" "$from" "$to" || die
}

get_userspec_arg() {
    local uid="$(find_user_info uid)" gid="$(find_user_info gid)"
    echo "--userspec=$uid:$gid"
}

add_user_arg() {
    local _A= uid="$(find_user_info uid)"

    case $container_type in
        nspawn|docker)
            _A="--user=$uid" ;;
    esac

    eval "${1}=\"\$${1}$S$_A\""
}

add_privileged_arg() {
    local _A=

    [ "${share_system-}" ] || return 0

    case $container_type in
        nspawn)
            _A="--share-system" ;;
        docker)
            _A="--privileged" ;;
    esac

    eval "${1}=\"\$${1}$S$_A\""
}

make_setarch() {
    case $root_arch in
        x86|i?86)
            echo "linux32" ;;
        x86-64|x86_64|amd64)
            echo "linux64" ;;
    esac
}

make_env_arg() {
    local value="$1"
    case $container_type in
        chroot) echo "$value" ;;
        nspawn) echo "--setenv=$value" ;;
        docker) echo "--env=$value" ;;
    esac
}

make_bind_arg() {
    local value="$1"
    case $container_type in
        nspawn) echo "--bind=$value" ;;
        docker) echo "--volume=$value" ;;
    esac
}

setup_filesystems() {
    [ "$container_type" = "chroot" ] || return 0

    if [ "$share_system" ]; then
        su_run mkdir -p "$root_dir/sys"            || die
        su_run mount --rbind /sys "$root_dir/sys"  || die
        su_run mount --make-rslave "$root_dir/sys" || die
        su_run mkdir -p "$root_dir/dev"            || die
        su_run mount --rbind /dev "$root_dir/dev"  || die
        su_run mount --make-rslave "$root_dir/dev" || die
    else
        if [ -h "$root_dir/dev/shm" ]; then
            su_run rm "$root_dir/dev/shm" || die
        fi
        su_run mkdir -p "$root_dir/dev/shm" "$root_dir/dev/pts" || die
    fi
}

setup_runtime_env() {
    local _A= config_dir= runtime_dir= uid= gid=

    config_dir=$(get_config_dir)
    runtime_dir=$(get_runtime_dir)

    case $container_type in
        chroot)
            _A="$_A$S$(make_env_arg TERM=$TERM)"
            _A="$_A$S$(make_env_arg HOME=$container_home)"
            _A="$_A$S$(make_env_arg USER=$container_user)"
            _A="$_A$S$(make_env_arg LOGNAME=$container_user)"

            if [ "$container_user" = "root" ]; then
                _A="$_A$S$(make_env_arg PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin)"
            else
                _A="$_A$S$(make_env_arg PATH=/usr/local/bin:/usr/bin:/bin)"
            fi

            in_mkdir "$root_dir/$runtime_dir" 700
            ;;
        nspawn)
            uid=$(find_user_info uid)
            gid=$(find_user_info gid)

            _A="$_A$S--tmpfs=$runtime_dir:uid=$uid,gid=$gid,mode=700"
            ;;
    esac

    _A="$_A$S$(make_env_arg "XDG_CONFIG_HOME=$config_dir")"
    _A="$_A$S$(make_env_arg "XDG_RUNTIME_DIR=$runtime_dir")"

    if [ "$root_dir" ]; then
        in_mkdir "$root_dir/$config_dir"
    fi

    eval "${1}=\"\$${1}$S$_A\""
}

setup_ssh_env() {
    local SSH_A= uid= ssh_sock=

    [ "${with_ssh_agent-}" ] || return 0

    [ "${SSH_AUTH_SOCK-}" ] ||
        die "SSH_AUTH_SOCK is not set"
    [ -S "$SSH_AUTH_SOCK" ] ||
        die "$SSH_AUTH_SOCK socket is not exists"

    uid=$(find_user_info uid)
    ssh_sock=$(get_runtime_dir)/ssh

    SSH_A="$SSH_A$S$(make_env_arg "SSH_AUTH_SOCK=$ssh_sock")"

    case $container_type in
        chroot)
            in_mount2 "$SSH_AUTH_SOCK" "$root_dir/$ssh_sock" --bind
            ;;
        *)
            SSH_A="$SSH_A$S$(make_bind_arg "$SSH_AUTH_SOCK:$ssh_sock")"
            ;;
    esac

    if [ "$UID" != "$uid" ]; then
        warn "current UID ($UID) does not match UID inside the container \
($uid) but SSH socket sharing is requested -- changing $SSH_AUTH_SOCK mode to 777"
        su_run chmod 777 "$SSH_AUTH_SOCK" || die
    fi

    eval "${1}=\"\$${1}$S$SSH_A\""
}

setup_x11_env() {
    local X11_A=

    [ "${with_x11-}" ] || return 0

    [ "$DISPLAY" ] ||
        die "passing of X11 environment is enabled but DISPLAY is not set"
    [ -d "$xsock_dir" ] ||
        die "X11 socket directory '$xsock_dir' is not exists"

    extract_xauth
    [ -f "$xauth_file" ] || die "no X authority file"
    [ -d "$xsock_dir"  ] || die "no X socket directory"

    X11_A="$X11_A$S$(make_env_arg "DISPLAY=$DISPLAY")"
    X11_A="$X11_A$S$(make_env_arg "XAUTHORITY=$xauth_file")"

    # disable Qt's usage of shared memory which we do not expose
    X11_A="$X11_A$S$(make_env_arg QT_X11_NO_MITSHM=1)"

    case $container_type in
        chroot)
            in_touch "$root_dir/$xauth_file"
            in_mkdir "$root_dir/$xsock_dir"
            in_mount --bind "$xauth_file" "$root_dir/$xauth_file"
            in_mount --bind "$xsock_dir" "$root_dir/$xsock_dir"
            ;;
        *)
            X11_A="$X11_A$S$(make_bind_arg "$xauth_file:$xauth_file")"
            X11_A="$X11_A$S$(make_bind_arg "$xsock_dir:$xsock_dir")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$X11_A\""
}

setup_pa_env() {
    local PA_A=
    local pa_sock= in_pa_sock=
    local cookie_file= in_cookie_file=

    [ "${with_pulseaudio-}" ] || return 0

    pa_sock=$(get_pa_socket)
    in_pa_sock="$(get_runtime_dir pulse)/native"

    [ -S "$pa_sock" ] || die "PulseAudio socket '$pa_sock' does not exist"

    cookie_file="${XDG_CONFIG_HOME:-${HOME:?}/.config}/pulse/cookie"
    in_cookie_file="$(get_config_dir pulse)/cookie"

    [ -f "$cookie_file" ] ||
        die "PulseAudio cookie file '$cookie_file' is not found"

    PA_A="$PA_A$S$(make_env_arg "PULSE_SERVER=$in_pa_sock")"

    case $container_type in
        chroot)
            in_touch "$root_dir/$in_pa_sock"
            in_touch "$root_dir/$in_cookie_file"
            in_mount --bind "$pa_sock" "$root_dir/$in_pa_sock"
            in_mount --bind "$cookie_file" "$root_dir/$in_cookie_file"
            ;;
        *)
            PA_A="$PA_A$S$(make_bind_arg "$pa_sock:$in_pa_sock")"
            PA_A="$PA_A$S$(make_bind_arg "$cookie_file:$in_cookie_file")"
            ;;
    esac

    chmod 644 "$cookie_file" || die

    eval "${1}=\"\$${1}$S$PA_A\""
}

setup_home_env() {
    local HOME_A=

    [ "$bind_home" ] || return 0

    [ -d "$bind_home" ] ||
        die "The directory '$bind_home' is not exists"

    if [ "$root_dir" ]; then
        in_mkdir "$root_dir/$container_home"
    fi

    if [ "$container_type" = "chroot" ]; then
        in_mount --bind "$bind_home" "$root_dir/$container_home"
    else
        HOME_A="$HOME_A$S$(make_bind_arg "$bind_home:$container_home")"
    fi

    eval "${1}=\"\$${1}$S$HOME_A\""
}

setup_env() {
    setup_filesystems  "$1"
    add_user_arg       "$1"
    add_privileged_arg "$1"
    setup_runtime_env  "$1"
    setup_ssh_env      "$1"
    setup_x11_env      "$1"
    setup_pa_env       "$1"
    setup_home_env     "$1"
}

extract_xauth() {
    xauth_file=$(mktemp)
    # Use wildcard authentication family because hostname of container can
    # differ from the host and default Xauthority files are hostname specific.
    # See http://stackoverflow.com/a/25280523 for details.
    xauth nlist "$DISPLAY" | sed 's/^..../ffff/' | xauth -f "$xauth_file" nmerge -
}

copy_resolv_conf() {
    su_run cp -L /etc/resolv.conf "$root_dir/etc/resolv.conf" ||
        die "failed to copy resolv.conf"
}

fix_mtab() {
    if [ ! -h "$root_dir/etc/mtab" ]; then
        su_run ln -sf /proc/self/mounts "$root_dir/etc/mtab" ||
            die "failed to link mtab"
    fi
}

cleanup() {
    local root=

    if [ "$container_type" = 'chroot' ]; then
        root="$(realpath "$root_dir")"
        for mp in $(awk -v i="$root" '$2~i {print $2}' /proc/mounts | tac)
        do
            su_run umount "$mp" || true
        done
    fi

    if [ "$xauth_file" ]; then
        su_run rm -f "$xauth_file"
        if [ "$root_dir" ]; then
            su_run rm -f "$root_dir/$xauth_file"
        fi
    fi
}

spawn_root_chroot() {
    local IFS="$S" env= cmd=

    setup_env env

    cmd="mount -t proc proc \"$root_dir/proc\""

    if ! [ "$share_system" ]; then
        cmd="$cmd && mount -t tmpfs -o nosuid,nodev,noexec shm \"$root_dir/dev/shm\""
        cmd="$cmd && mount -t devpts -o nosuid,noexec,gid=5,mode=620 devpts \"$root_dir/dev/pts\""
    fi

    cmd="$cmd && $chroot $(get_userspec_arg) \"$root_dir\" $(get_command)"

    su_run $(make_setarch) env - $env unshare -m /bin/sh -c "$cmd"
}

spawn_root_nspawn() {
    local IFS="$S" A=

    # systemd-nspawn runs 'getent passwd <user>' inside the container to get
    # passwd entry for the user or fails with "Failed to resolve user <user>"

    setup_env A

    su_run systemd-nspawn $A $passthrough_args -D "$root_dir" -- $(get_command)
}

spawn_root_docker() {
    local IFS="$S" A=

    setup_env A

    docker run --rm -it $A $passthrough_args $container_name $(get_command)
}

if [ $# = 0 ]; then
    show_usage
    exit
fi

parse_command_line "$@"
validate_environment

if [ "$cleanup_only" ]; then
    cleanup
    exit
fi

trap cleanup EXIT

container_home=$(find_user_info home)
[ "$container_home" ] ||
    die "failed to find user's home directory"

if [ "$container_name" ]; then
    spawn_root_docker
elif [ "$root_dir" ]; then
    if [ "$container_type" = 'nspawn' ]; then
        spawn_root_nspawn
    else
        spawn_root_chroot
    fi
else
    die "container name or chroot directory is not specified"
fi
